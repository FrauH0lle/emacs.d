#+TITLE: archive

Useful code snippets or code which is not in use but I spent too much time on it
to just dispose it.

* Snippets

** Persist Emacs window

#+BEGIN_SRC emacs-lisp
(when-let (dims (+emacs-cache-get 'last-frame-size))
  (cl-destructuring-bind ((left . top) width height fullscreen) dims
    (setq initial-frame-alist
          (append initial-frame-alist
                  `((left . ,left)
                    (top . ,top)
                    (width . ,width)
                    (height . ,height)
                    (fullscreen . ,fullscreen))))))

(defun save-frame-dimensions ()
  (+emacs-cache-set 'last-frame-size
                  (list (frame-position)
                        (frame-width)
                        (frame-height)
                        (frame-parameter nil 'fullscreen))))

(add-hook 'kill-emacs-hook #'save-frame-dimensions)
#+END_SRC
* Org
** TAB indent

#+begin_src emacs-lisp
;;;###autoload
(defun +org--hook-indent-maybe ()
  "Indent the current item (header or item), if possible.
Made for `org-tab-first-hook' in evil-mode."
  (interactive)
  (cond ((not (and (bound-and-true-p evil-local-mode)
                   (or (evil-insert-state-p)
                       (evil-emacs-state-p))))
        nil)
        ((org-at-item-p)
         (if (eq this-command 'org-shifttab)
             (org-outdent-item-tree)
           (org-indent-item-tree))
         t)
        ((org-at-heading-p)
         (ignore-errors
           (if (eq this-command 'org-shifttab)
               (org-promote)
             (org-demote)))
         t)
        ((org-in-src-block-p t)
         (org-babel-do-in-edit-buffer
          (call-interactively #'indent-for-tab-command))
         t)))
#+end_src
** yasnippet TAB expand

#+begin_src emacs-lisp
;;;###autoload
(defun +org--hook-yas-expand-maybe ()
  "Tries to expand a yasnippet snippet, if one is available. Made for
`org-tab-first-hook'."
  (when (bound-and-true-p yas-minor-mode)
    (let ((major-mode (if (org-in-src-block-p t)
                          (org-src-get-lang-mode (org-eldoc-get-src-lang))
                        major-mode))
          (org-src-tab-acts-natively nil) ; causes breakages
          ;; Smart indentation doesn't work with yasnippet, and painfully slow
          ;; in the few cases where it does.
          (yas-indent-line 'fixed))
      (cond ((and (or (not (bound-and-true-p evil-local-mode))
                           (evil-insert-state-p)
                           (evil-emacs-state-p))
                  (yas--templates-for-key-at-point))
             (yas-expand)
             t)
            ((use-region-p)
             (yas-insert-snippet)
             t)))))
#+end_src
* Env file with Fish shell in interactive session

#+begin_src emacs-lisp
(defun +emacs-reload-env-file (&optional force-p env-file whitelist blacklist fish-shell)
  "Generates `+emacs-env-file', if it doesn't exist (or if FORCE-P).
This scrapes the variables from your shell environment by running
`+emacs-env-executable' through `shell-file-name' with
`+emacs-env-switches'. By default, on Linux, this is '$SHELL -ic
/usr/bin/env'. Variables in `+emacs-env-blacklist' are
removed."
  (let ((env-file (if env-file (expand-file-name env-file) +emacs-env-file))
        (process-environment (if fish-shell
                                 (let ((default-directory user-emacs-directory))
                                   (split-string
                                    (cdr (+emacs-call-process "fish" "-c" "\"$SHELL\" -ic /usr/bin/env")) "\n"))
                               +emacs--initial-process-environment)))
    (when (or force-p (not (file-exists-p env-file)))
      (with-temp-file env-file
        (setq-local coding-system-for-write 'utf-8-unix)
        (print! (start "%s envvars file at %S")
                (if (file-exists-p env-file)
                    "Regenerating"
                  "Generating")
                (path env-file))
        (print-group!
         (when +emacs-interactive-p
           (user-error "Command must be run in a non-interactive session, not an interactive session"))
         (goto-char (point-min))
         (insert
          (concat
           "# -*- mode: sh; coding: utf-8-unix -*-\n"
           (format "# Generated from a %s shell environent\n" shell-file-name)
           "# ---------------------------------------------------------------------------\n"
           "# This file was auto-generated by `+emacs-reload-env-file'. It contains a\n"
           "# list of environment variables scraped from your default shell\n"
           "# (excluding variables blacklisted in +emacs-env-blacklist).\n"
           "#\n"
           (if (file-equal-p env-file +emacs-env-file)
               (concat "# It is NOT safe to edit this file. Changes will be overwritten next time you\n"
                       "# run '+emacs/refresh'. Create a safe-to-edit envvar file in\n"
                       "# \"~/.emacs.d/myenv\"\n"
                       "# And load it with (+emacs-load-envvars-file \"~/.+emacs.d/myenv\").\n")
             (concat "# This file is safe to edit by hand, but needs to be loaded manually with:\n#\n"
                     "#   (+emacs-load-envvars-file \"path/to/this/file\")\n#\n"
                     "# Use '+emacs/refresh' to regenerate it.\n"))
           "# ---------------------------------------------------------------------------\n\n"))
         ;; We assume that this noninteractive session was spawned from the user's interactive
         ;; shell, therefore we just dump `process-environment' to a file.
         (dolist (env process-environment)
           (if (cl-find-if (+emacs-rpartial #'string-match-p (car (split-string env "=")))
                           (remq nil (append blacklist +emacs-env-blacklist)))
               (if (not (cl-find-if (+emacs-rpartial #'string-match-p (car (split-string env "=")))
                                    (remq nil (append whitelist +emacs-env-whitelist))))
                   (print! (debug "Ignoring %s") env)
                 (print! (debug "Whitelisted %s") env)
                 (insert env "\0\n"))
             (insert env "\0\n")))
         (print! (success "Successfully generated %S")
                 (path env-file))
         t)))))
#+end_src
* Polymode hydra

#+begin_src emacs-lisp
(defhydra +polymode-hydra ()
  ;; navigation
  ("j" polymode-next-chunk "Next Chunk" :column "Navigation" :exit t)
  ("k" polymode-previous-chunk "Previous Chunk" :exit t)
  ("C-j" polymode-next-chunk-same-type "Next Chunk (Type)" :exit t)
  ("C-k" polymode-previous-chunk-same-type "Previous Chunk (Type)" :exit t)
  ("J" markdown-next-visible-heading "Next Header")
  ("K" markdown-previous-visible-heading "Previous Header")

  ;; eval
  ("v" polymode-eval-region-or-chunk "Eval Chunk" :column "Eval" :exit t)
  ("b" polymode-eval-buffer "Eval Buffer" :exit t)
  ("u" polymode-eval-buffer-from-beg-to-point "Eval to point" :exit t)
  ("d" polymode-eval-buffer-from-point-to-end "Eval from point" :exit t)

  ;; chunk manipulation
  ("D" polymode-kill-chunk "Kill" :column "Chunk")
  ("m" polymode-mark-or-extend-chunk "Mark")
  ("C-t" polymode-toggle-chunk-narrowing "Toggle Narrow" :exit t)

  ;; backends
  ("e" polymode-export "Export" :column "Export" :exit t)
  ("E" polymode-set-exporter "Set Exporter" :exit t)
  ("w" polymode-weave "Weave" :exit t)
  ("W" polymode-set-weaver "Set Weaver" :exit t)
  ("t" polymode-tangle "Tangle" :exit t)
  ("T" polymode-set-tangler "Set Tangler" :exit t)
  ("$" polymode-show-process-buffer "Show Processes" :exit t)

  ("q" nil "Quit" :column "" :exit t))
#+end_src
* evil holy mode

#+begin_src emacs-lisp
(module! (:editor evil +holy)

  (after! evil
    ;; Use 'emacs as `evil-default-state'
    (setq evil-default-state 'emacs)
    ;; Make all buffers' initial state emacs
    (push '("." . emacs) evil-buffer-regexps)

    ;; Swap default and emacs cursor colors
    (defhook! +evil--hook-update-cursor-color ()
      "Change the cursor color."
      '(+emacs-load-theme-hook +emacs-init-modules-hook)
      (put 'cursor 'evil-emacs-color  (face-foreground 'cursor))
      (put 'cursor 'evil-normal-color (face-background 'warning)))

    (defadvice! +emacs--advice-enable-holy-mode ()
      "Force `evil-emacs-state'."
      :override '(evil-motion-state
                  evil-normal-state
                  evil-insert-state)
      (evil-emacs-state))))
#+end_src
* deDE input

#+begin_src emacs-lisp
;;
;;; input

;;;; deDE

(module! (:input deDE)

  ;; This module makes some modifications to the keybindings when using a german
  ;; keyboard

  ;; Use Ctrl-Alt as a an alternative for AltGr for keys on the right side of
  ;; the keyboard. Windows should do this automatically, thus this should not be
  ;; necesassary.

  (define-key key-translation-map (kbd "C-M-7") (kbd "\{"))
  (define-key key-translation-map (kbd "C-M-8") (kbd "\["))
  (define-key key-translation-map (kbd "C-M-9") (kbd "\]"))
  (define-key key-translation-map (kbd "C-M-0") (kbd "\}"))
  (define-key key-translation-map (kbd "C-M-ÃŸ") (kbd "\\"))
  (define-key key-translation-map (kbd "C-M-+") (kbd "\~")))
#+end_src
